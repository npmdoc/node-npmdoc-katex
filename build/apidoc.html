<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/Khan/KaTeX#readme"

    >katex (v0.7.1)</a>
</h1>
<h4>Fast math typesetting for the web.</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.katex">module katex</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.katex.Lexer">
            function <span class="apidocSignatureSpan">katex.</span>Lexer
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.katex.MacroExpander">
            function <span class="apidocSignatureSpan">katex.</span>MacroExpander
            <span class="apidocSignatureSpan">(input, macros)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.katex.Options">
            function <span class="apidocSignatureSpan">katex.</span>Options
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.katex.ParseError">
            function <span class="apidocSignatureSpan">katex.</span>ParseError
            <span class="apidocSignatureSpan">(message, token)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.katex.Parser">
            function <span class="apidocSignatureSpan">katex.</span>Parser
            <span class="apidocSignatureSpan">(input, settings)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.katex.__parse">
            function <span class="apidocSignatureSpan">katex.</span>__parse
            <span class="apidocSignatureSpan">(expression, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.katex.render">
            function <span class="apidocSignatureSpan">katex.</span>render
            <span class="apidocSignatureSpan">(expression, baseNode, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.katex.renderToString">
            function <span class="apidocSignatureSpan">katex.</span>renderToString
            <span class="apidocSignatureSpan">(expression, options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">katex.</span>Lexer.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">katex.</span>MacroExpander.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">katex.</span>Options.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">katex.</span>Parser.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">katex.</span>buildCommon</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">katex.</span>delimiter</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">katex.</span>domTree</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">katex.</span>fontMetrics</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">katex.</span>mathMLTree</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">katex.</span>parseData</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">katex.</span>utils</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.katex.Lexer">module katex.Lexer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.katex.Lexer.Lexer">
            function <span class="apidocSignatureSpan">katex.</span>Lexer
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.katex.Lexer.prototype">module katex.Lexer.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.katex.Lexer.prototype.lex">
            function <span class="apidocSignatureSpan">katex.Lexer.prototype.</span>lex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.katex.MacroExpander">module katex.MacroExpander</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.katex.MacroExpander.MacroExpander">
            function <span class="apidocSignatureSpan">katex.</span>MacroExpander
            <span class="apidocSignatureSpan">(input, macros)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.katex.MacroExpander.prototype">module katex.MacroExpander.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.katex.MacroExpander.prototype.get">
            function <span class="apidocSignatureSpan">katex.MacroExpander.prototype.</span>get
            <span class="apidocSignatureSpan">(ignoreSpace)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.katex.MacroExpander.prototype.nextToken">
            function <span class="apidocSignatureSpan">katex.MacroExpander.prototype.</span>nextToken
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.katex.MacroExpander.prototype.unget">
            function <span class="apidocSignatureSpan">katex.MacroExpander.prototype.</span>unget
            <span class="apidocSignatureSpan">(token)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.katex.Options">module katex.Options</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.katex.Options.Options">
            function <span class="apidocSignatureSpan">katex.</span>Options
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.katex.Options.prototype">module katex.Options.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.katex.Options.prototype.extend">
            function <span class="apidocSignatureSpan">katex.Options.prototype.</span>extend
            <span class="apidocSignatureSpan">(extension)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.katex.Options.prototype.getColor">
            function <span class="apidocSignatureSpan">katex.Options.prototype.</span>getColor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.katex.Options.prototype.reset">
            function <span class="apidocSignatureSpan">katex.Options.prototype.</span>reset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.katex.Options.prototype.withColor">
            function <span class="apidocSignatureSpan">katex.Options.prototype.</span>withColor
            <span class="apidocSignatureSpan">(color)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.katex.Options.prototype.withFont">
            function <span class="apidocSignatureSpan">katex.Options.prototype.</span>withFont
            <span class="apidocSignatureSpan">(font)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.katex.Options.prototype.withPhantom">
            function <span class="apidocSignatureSpan">katex.Options.prototype.</span>withPhantom
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.katex.Options.prototype.withSize">
            function <span class="apidocSignatureSpan">katex.Options.prototype.</span>withSize
            <span class="apidocSignatureSpan">(size)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.katex.Options.prototype.withStyle">
            function <span class="apidocSignatureSpan">katex.Options.prototype.</span>withStyle
            <span class="apidocSignatureSpan">(style)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.katex.Parser">module katex.Parser</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.katex.Parser.Parser">
            function <span class="apidocSignatureSpan">katex.</span>Parser
            <span class="apidocSignatureSpan">(input, settings)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.katex.Parser.prototype">module katex.Parser.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.katex.Parser.prototype.ParseNode">
            function <span class="apidocSignatureSpan">katex.Parser.prototype.</span>ParseNode
            <span class="apidocSignatureSpan">(type, value, mode, firstToken, lastToken)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.katex.Parser.prototype.callFunction">
            function <span class="apidocSignatureSpan">katex.Parser.prototype.</span>callFunction
            <span class="apidocSignatureSpan">(name, args, positions, token)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.katex.Parser.prototype.consume">
            function <span class="apidocSignatureSpan">katex.Parser.prototype.</span>consume
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.katex.Parser.prototype.expect">
            function <span class="apidocSignatureSpan">katex.Parser.prototype.</span>expect
            <span class="apidocSignatureSpan">(text, consume)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.katex.Parser.prototype.formLigatures">
            function <span class="apidocSignatureSpan">katex.Parser.prototype.</span>formLigatures
            <span class="apidocSignatureSpan">(group)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.katex.Parser.prototype.handleInfixNodes">
            function <span class="apidocSignatureSpan">katex.Parser.prototype.</span>handleInfixNodes
            <span class="apidocSignatureSpan">(body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.katex.Parser.prototype.handleSupSubscript">
            function <span class="apidocSignatureSpan">katex.Parser.prototype.</span>handleSupSubscript
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.katex.Parser.prototype.handleUnsupportedCmd">
            function <span class="apidocSignatureSpan">katex.Parser.prototype.</span>handleUnsupportedCmd
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.katex.Parser.prototype.parse">
            function <span class="apidocSignatureSpan">katex.Parser.prototype.</span>parse
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.katex.Parser.prototype.parseArguments">
            function <span class="apidocSignatureSpan">katex.Parser.prototype.</span>parseArguments
            <span class="apidocSignatureSpan">(func, funcData)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.katex.Parser.prototype.parseAtom">
            function <span class="apidocSignatureSpan">katex.Parser.prototype.</span>parseAtom
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.katex.Parser.prototype.parseColorGroup">
            function <span class="apidocSignatureSpan">katex.Parser.prototype.</span>parseColorGroup
            <span class="apidocSignatureSpan">(optional)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.katex.Parser.prototype.parseExpression">
            function <span class="apidocSignatureSpan">katex.Parser.prototype.</span>parseExpression
            <span class="apidocSignatureSpan">(breakOnInfix, breakOnTokenText)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.katex.Parser.prototype.parseFunction">
            function <span class="apidocSignatureSpan">katex.Parser.prototype.</span>parseFunction
            <span class="apidocSignatureSpan">(baseGroup)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.katex.Parser.prototype.parseGroup">
            function <span class="apidocSignatureSpan">katex.Parser.prototype.</span>parseGroup
            <span class="apidocSignatureSpan">(optional)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.katex.Parser.prototype.parseGroupOfType">
            function <span class="apidocSignatureSpan">katex.Parser.prototype.</span>parseGroupOfType
            <span class="apidocSignatureSpan">(innerMode, optional)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.katex.Parser.prototype.parseImplicitGroup">
            function <span class="apidocSignatureSpan">katex.Parser.prototype.</span>parseImplicitGroup
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.katex.Parser.prototype.parseInput">
            function <span class="apidocSignatureSpan">katex.Parser.prototype.</span>parseInput
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.katex.Parser.prototype.parseRegexGroup">
            function <span class="apidocSignatureSpan">katex.Parser.prototype.</span>parseRegexGroup
            <span class="apidocSignatureSpan">(regex, modeName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.katex.Parser.prototype.parseSizeGroup">
            function <span class="apidocSignatureSpan">katex.Parser.prototype.</span>parseSizeGroup
            <span class="apidocSignatureSpan">(optional)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.katex.Parser.prototype.parseStringGroup">
            function <span class="apidocSignatureSpan">katex.Parser.prototype.</span>parseStringGroup
            <span class="apidocSignatureSpan">(modeName, optional)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.katex.Parser.prototype.parseSymbol">
            function <span class="apidocSignatureSpan">katex.Parser.prototype.</span>parseSymbol
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.katex.Parser.prototype.switchMode">
            function <span class="apidocSignatureSpan">katex.Parser.prototype.</span>switchMode
            <span class="apidocSignatureSpan">(newMode)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.katex.buildCommon">module katex.buildCommon</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.katex.buildCommon.makeFragment">
            function <span class="apidocSignatureSpan">katex.buildCommon.</span>makeFragment
            <span class="apidocSignatureSpan">(children)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.katex.buildCommon.makeOrd">
            function <span class="apidocSignatureSpan">katex.buildCommon.</span>makeOrd
            <span class="apidocSignatureSpan">(group, options, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.katex.buildCommon.makeSpan">
            function <span class="apidocSignatureSpan">katex.buildCommon.</span>makeSpan
            <span class="apidocSignatureSpan">(classes, children, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.katex.buildCommon.makeSymbol">
            function <span class="apidocSignatureSpan">katex.buildCommon.</span>makeSymbol
            <span class="apidocSignatureSpan">(value, fontFamily, mode, options, classes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.katex.buildCommon.makeVList">
            function <span class="apidocSignatureSpan">katex.buildCommon.</span>makeVList
            <span class="apidocSignatureSpan">(children, positionType, positionData, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.katex.buildCommon.mathsym">
            function <span class="apidocSignatureSpan">katex.buildCommon.</span>mathsym
            <span class="apidocSignatureSpan">(value, mode, options, classes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.katex.buildCommon.prependChildren">
            function <span class="apidocSignatureSpan">katex.buildCommon.</span>prependChildren
            <span class="apidocSignatureSpan">(span, children)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">katex.buildCommon.</span>fontMap</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">katex.buildCommon.</span>sizingMultiplier</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">katex.buildCommon.</span>spacingFunctions</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.katex.delimiter">module katex.delimiter</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.katex.delimiter.customSizedDelim">
            function <span class="apidocSignatureSpan">katex.delimiter.</span>customSizedDelim
            <span class="apidocSignatureSpan">(delim, height, center, options, mode, classes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.katex.delimiter.leftRightDelim">
            function <span class="apidocSignatureSpan">katex.delimiter.</span>leftRightDelim
            <span class="apidocSignatureSpan">(delim, height, depth, options, mode, classes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.katex.delimiter.sizedDelim">
            function <span class="apidocSignatureSpan">katex.delimiter.</span>sizedDelim
            <span class="apidocSignatureSpan">(delim, size, options, mode, classes)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.katex.domTree">module katex.domTree</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.katex.domTree.documentFragment">
            function <span class="apidocSignatureSpan">katex.domTree.</span>documentFragment
            <span class="apidocSignatureSpan">(children)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.katex.domTree.span">
            function <span class="apidocSignatureSpan">katex.domTree.</span>span
            <span class="apidocSignatureSpan">(classes, children, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.katex.domTree.symbolNode">
            function <span class="apidocSignatureSpan">katex.domTree.</span>symbolNode
            <span class="apidocSignatureSpan">(value, height, depth, italic, skew, classes, style)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.katex.fontMetrics">module katex.fontMetrics</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.katex.fontMetrics.getCharacterMetrics">
            function <span class="apidocSignatureSpan">katex.fontMetrics.</span>getCharacterMetrics
            <span class="apidocSignatureSpan">(character, style)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">katex.fontMetrics.</span>metrics</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">katex.fontMetrics.</span>sigmas</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.katex.mathMLTree">module katex.mathMLTree</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.katex.mathMLTree.MathNode">
            function <span class="apidocSignatureSpan">katex.mathMLTree.</span>MathNode
            <span class="apidocSignatureSpan">(type, children)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.katex.mathMLTree.TextNode">
            function <span class="apidocSignatureSpan">katex.mathMLTree.</span>TextNode
            <span class="apidocSignatureSpan">(text)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.katex.parseData">module katex.parseData</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.katex.parseData.ParseNode">
            function <span class="apidocSignatureSpan">katex.parseData.</span>ParseNode
            <span class="apidocSignatureSpan">(type, value, mode, firstToken, lastToken)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.katex.utils">module katex.utils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.katex.utils.clearNode">
            function <span class="apidocSignatureSpan">katex.utils.</span>clearNode
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.katex.utils.contains">
            function <span class="apidocSignatureSpan">katex.utils.</span>contains
            <span class="apidocSignatureSpan">(list, elem)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.katex.utils.deflt">
            function <span class="apidocSignatureSpan">katex.utils.</span>deflt
            <span class="apidocSignatureSpan">(setting, defaultIfUndefined)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.katex.utils.escape">
            function <span class="apidocSignatureSpan">katex.utils.</span>escape
            <span class="apidocSignatureSpan">(text)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.katex.utils.hyphenate">
            function <span class="apidocSignatureSpan">katex.utils.</span>hyphenate
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.katex.utils.indexOf">
            function <span class="apidocSignatureSpan">katex.utils.</span>indexOf
            <span class="apidocSignatureSpan">(list, elem)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.katex" id="apidoc.module.katex">module katex</a></h1>


    <h2>
        <a href="#apidoc.element.katex.Lexer" id="apidoc.element.katex.Lexer">
        function <span class="apidocSignatureSpan">katex.</span>Lexer
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Lexer(input) {
    this.input = input;
    this.pos = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.katex.MacroExpander" id="apidoc.element.katex.MacroExpander">
        function <span class="apidocSignatureSpan">katex.</span>MacroExpander
        <span class="apidocSignatureSpan">(input, macros)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MacroExpander(input, macros) {
    this.lexer = new Lexer(input);
    this.macros = macros;
    this.stack = []; // contains tokens in REVERSE order
    this.discardedWhiteSpace = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.katex.Options" id="apidoc.element.katex.Options">
        function <span class="apidocSignatureSpan">katex.</span>Options
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Options(data) {
    this.style = data.style;
    this.color = data.color;
    this.size = data.size;
    this.phantom = data.phantom;
    this.font = data.font;

    if (data.parentStyle === undefined) {
        this.parentStyle = data.style;
    } else {
        this.parentStyle = data.parentStyle;
    }

    if (data.parentSize === undefined) {
        this.parentSize = data.size;
    } else {
        this.parentSize = data.parentSize;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.katex.ParseError" id="apidoc.element.katex.ParseError">
        function <span class="apidocSignatureSpan">katex.</span>ParseError
        <span class="apidocSignatureSpan">(message, token)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ParseError(message, token) {
    var error = &#x22;KaTeX parse error: &#x22; + message;
    var start;
    var end;

    if (token &#x26;&#x26; token.lexer &#x26;&#x26; token.start &#x3c;= token.end) {
        // If we have the input and a position, make the error a bit fancier

        // Get the input
        var input = token.lexer.input;

        // Prepend some information
        start = token.start;
        end = token.end;
        if (start === input.length) {
            error += &#x22; at end of input: &#x22;;
        } else {
            error += &#x22; at position &#x22; + (start + 1) + &#x22;: &#x22;;
        }

        // Underline token in question using combining underscores
        var underlined = input.slice(start, end).replace(/[^]/g, &#x22;$&#x26;\u0332&#x22;);

        // Extract some context from the input and add it to the error
        var left;
        if (start &#x3e; 15) {
            left = &#x22;…&#x22; + input.slice(start - 15, start);
        } else {
            left = input.slice(0, start);
        }
        var right;
        if (end + 15 &#x3c; input.length) {
            right = input.slice(end, end + 15) + &#x22;…&#x22;;
        } else {
            right = input.slice(end);
        }
        error += left + underlined + right;
    }

    // Some hackery to make ParseError a prototype of Error
    // See http://stackoverflow.com/a/8460753
    var self = new Error(error);
    self.name = &#x22;ParseError&#x22;;
    self.__proto__ = ParseError.prototype;

    self.position = start;
    return self;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.katex.Parser" id="apidoc.element.katex.Parser">
        function <span class="apidocSignatureSpan">katex.</span>Parser
        <span class="apidocSignatureSpan">(input, settings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Parser(input, settings) {
    // Create a new macro expander (gullet) and (indirectly via that) also a
    // new lexer (mouth) for this parser (stomach, in the language of TeX)
    this.gullet = new MacroExpander(input, settings.macros);
    // Store the settings for use in parsing
    this.settings = settings;
    // Count leftright depth (for \middle errors)
    this.leftrightDepth = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.katex.__parse" id="apidoc.element.katex.__parse">
        function <span class="apidocSignatureSpan">katex.</span>__parse
        <span class="apidocSignatureSpan">(expression, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">__parse = function (expression, options) {
    var settings = new Settings(options);
    return parseTree(expression, settings);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.katex.render" id="apidoc.element.katex.render">
        function <span class="apidocSignatureSpan">katex.</span>render
        <span class="apidocSignatureSpan">(expression, baseNode, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">render = function (expression, baseNode, options) {
    utils.clearNode(baseNode);

    var settings = new Settings(options);

    var tree = parseTree(expression, settings);
    var node = buildTree(tree, expression, settings).toNode();

    baseNode.appendChild(node);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

#### In-browser rendering

Call `katex.render` with a TeX expression and a DOM element to render into:

```js
katex.<span class="apidocCodeKeywordSpan">render</span>(&#x22;c = \\pm\\sqrt{a^2 + b^2}&#x22;, element);
```

If KaTeX can&#x27;t parse the expression, it throws a `katex.ParseError` error.

#### Server side rendering or rendering to a string

To generate HTML on the server or to generate an HTML string of the rendered math, you can use `katex.renderToString`:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.katex.renderToString" id="apidoc.element.katex.renderToString">
        function <span class="apidocSignatureSpan">katex.</span>renderToString
        <span class="apidocSignatureSpan">(expression, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">renderToString = function (expression, options) {
    var settings = new Settings(options);

    var tree = parseTree(expression, settings);
    return buildTree(tree, expression, settings).toMarkup();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
If KaTeX can&#x27;t parse the expression, it throws a `katex.ParseError` error.

#### Server side rendering or rendering to a string

To generate HTML on the server or to generate an HTML string of the rendered math, you can use `katex.renderToString`:

```js
var html = katex.<span class="apidocCodeKeywordSpan">renderToString</span>(&#x22;c = \\pm\\sqrt{a^2 + b^2}&#x22;);
// &#x27;&#x3c;span class=&#x22;katex&#x22;&#x3e;...&#x3c;/span&#x3e;&#x27;
```

Make sure to include the CSS and font files, but there is no need to include the JavaScript. Like `render`, `renderToString` throws
 if it can&#x27;t parse the expression.

#### Rendering options
...</pre></li>
    </ul>
























</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.katex.Lexer" id="apidoc.module.katex.Lexer">module katex.Lexer</a></h1>


    <h2>
        <a href="#apidoc.element.katex.Lexer.Lexer" id="apidoc.element.katex.Lexer.Lexer">
        function <span class="apidocSignatureSpan">katex.</span>Lexer
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Lexer(input) {
    this.input = input;
    this.pos = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.katex.Lexer.prototype" id="apidoc.module.katex.Lexer.prototype">module katex.Lexer.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.katex.Lexer.prototype.lex" id="apidoc.element.katex.Lexer.prototype.lex">
        function <span class="apidocSignatureSpan">katex.Lexer.prototype.</span>lex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lex = function () {
    var input = this.input;
    var pos = this.pos;
    if (pos === input.length) {
        return new Token(&#x22;EOF&#x22;, pos, pos, this);
    }
    var match = matchAt(tokenRegex, input, pos);
    if (match === null) {
        throw new ParseError(
            &#x22;Unexpected character: &#x27;&#x22; + input[pos] + &#x22;&#x27;&#x22;,
            new Token(input[pos], pos, pos + 1, this));
    }
    var text = match[2] || &#x22; &#x22;;
    var start = this.pos;
    this.pos += match[0].length;
    var end = this.pos;
    return new Token(text, start, end, this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Recursively expand first token, then return first non-expandable token.
 */
MacroExpander.prototype.nextToken = function() {
for (;;) {
    if (this.stack.length === 0) {
        this.stack.push(this.lexer.<span class="apidocCodeKeywordSpan">lex</span>());
    }
    var topToken = this.stack.pop();
    var name = topToken.text;
    if (!(name.charAt(0) === &#x22;\\&#x22; &#x26;&#x26; this.macros.hasOwnProperty(name))) {
        return topToken;
    }
    var expansion = this.macros[name];
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.katex.MacroExpander" id="apidoc.module.katex.MacroExpander">module katex.MacroExpander</a></h1>


    <h2>
        <a href="#apidoc.element.katex.MacroExpander.MacroExpander" id="apidoc.element.katex.MacroExpander.MacroExpander">
        function <span class="apidocSignatureSpan">katex.</span>MacroExpander
        <span class="apidocSignatureSpan">(input, macros)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MacroExpander(input, macros) {
    this.lexer = new Lexer(input);
    this.macros = macros;
    this.stack = []; // contains tokens in REVERSE order
    this.discardedWhiteSpace = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.katex.MacroExpander.prototype" id="apidoc.module.katex.MacroExpander.prototype">module katex.MacroExpander.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.katex.MacroExpander.prototype.get" id="apidoc.element.katex.MacroExpander.prototype.get">
        function <span class="apidocSignatureSpan">katex.MacroExpander.prototype.</span>get
        <span class="apidocSignatureSpan">(ignoreSpace)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function (ignoreSpace) {
    this.discardedWhiteSpace = [];
    var token = this.nextToken();
    if (ignoreSpace) {
        while (token.text === &#x22; &#x22;) {
            this.discardedWhiteSpace.push(token);
            token = this.nextToken();
        }
    }
    return token;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

/**
 * Considers the current look ahead token as consumed,
 * and fetches the one after that as the new look ahead.
 */
Parser.prototype.consume = function() {
    this.nextToken = this.gullet.<span class="apidocCodeKeywordSpan">get</span>(this.mode === &#x22;math&#x22;);
};

Parser.prototype.switchMode = function(newMode) {
    this.gullet.unget(this.nextToken);
    this.mode = newMode;
    this.consume();
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.katex.MacroExpander.prototype.nextToken" id="apidoc.element.katex.MacroExpander.prototype.nextToken">
        function <span class="apidocSignatureSpan">katex.MacroExpander.prototype.</span>nextToken
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nextToken = function () {
    for (;;) {
        if (this.stack.length === 0) {
            this.stack.push(this.lexer.lex());
        }
        var topToken = this.stack.pop();
        var name = topToken.text;
        if (!(name.charAt(0) === &#x22;\\&#x22; &#x26;&#x26; this.macros.hasOwnProperty(name))) {
            return topToken;
        }
        var expansion = this.macros[name];
        if (typeof expansion === &#x22;string&#x22;) {
            var bodyLexer = new Lexer(expansion);
            expansion = [];
            var tok = bodyLexer.lex();
            while (tok.text !== &#x22;EOF&#x22;) {
                expansion.push(tok);
                tok = bodyLexer.lex();
            }
            expansion.reverse(); // to fit in with stack using push and pop
            this.macros[name] = expansion;
        }
        this.stack = this.stack.concat(expansion);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
    this.stack = this.stack.concat(expansion);
}
};

MacroExpander.prototype.get = function(ignoreSpace) {
this.discardedWhiteSpace = [];
var token = this.<span class="apidocCodeKeywordSpan">nextToken</span>();
if (ignoreSpace) {
    while (token.text === &#x22; &#x22;) {
        this.discardedWhiteSpace.push(token);
        token = this.nextToken();
    }
}
return token;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.katex.MacroExpander.prototype.unget" id="apidoc.element.katex.MacroExpander.prototype.unget">
        function <span class="apidocSignatureSpan">katex.MacroExpander.prototype.</span>unget
        <span class="apidocSignatureSpan">(token)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unget = function (token) {
    this.stack.push(token);
    while (this.discardedWhiteSpace.length !== 0) {
        this.stack.push(this.discardedWhiteSpace.pop());
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* and fetches the one after that as the new look ahead.
*/
Parser.prototype.consume = function() {
   this.nextToken = this.gullet.get(this.mode === &#x22;math&#x22;);
};

Parser.prototype.switchMode = function(newMode) {
   this.gullet.<span class="apidocCodeKeywordSpan">unget</span>(this.nextToken);
   this.mode = newMode;
   this.consume();
};

/**
* Main parsing function, which parses an entire input.
*
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.katex.Options" id="apidoc.module.katex.Options">module katex.Options</a></h1>


    <h2>
        <a href="#apidoc.element.katex.Options.Options" id="apidoc.element.katex.Options.Options">
        function <span class="apidocSignatureSpan">katex.</span>Options
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Options(data) {
    this.style = data.style;
    this.color = data.color;
    this.size = data.size;
    this.phantom = data.phantom;
    this.font = data.font;

    if (data.parentStyle === undefined) {
        this.parentStyle = data.style;
    } else {
        this.parentStyle = data.parentStyle;
    }

    if (data.parentSize === undefined) {
        this.parentSize = data.size;
    } else {
        this.parentSize = data.parentSize;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.katex.Options.prototype" id="apidoc.module.katex.Options.prototype">module katex.Options.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.katex.Options.prototype.extend" id="apidoc.element.katex.Options.prototype.extend">
        function <span class="apidocSignatureSpan">katex.Options.prototype.</span>extend
        <span class="apidocSignatureSpan">(extension)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extend = function (extension) {
    var data = {
        style: this.style,
        size: this.size,
        color: this.color,
        parentStyle: this.style,
        parentSize: this.size,
        phantom: this.phantom,
        font: this.font
    };

    for (var key in extension) {
        if (extension.hasOwnProperty(key)) {
            data[key] = extension[key];
        }
    }

    return new Options(data);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   return new Options(data);
};

/**
* Create a new options object with the given style.
*/
Options.prototype.withStyle = function(style) {
   return this.<span class="apidocCodeKeywordSpan">extend</span>({
       style: style
   });
};

/**
* Create a new options object with the given size.
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.katex.Options.prototype.getColor" id="apidoc.element.katex.Options.prototype.getColor">
        function <span class="apidocSignatureSpan">katex.Options.prototype.</span>getColor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getColor = function () {
    if (this.phantom) {
        return &#x22;transparent&#x22;;
    } else {
        return colorMap[this.color] || this.color;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        symbolNode = new domTree.symbolNode(value, 0, 0, 0, 0, classes);
    }

    if (options) {
        if (options.style.isTight()) {
            symbolNode.classes.push(&#x22;mtight&#x22;);
        }
        if (options.<span class="apidocCodeKeywordSpan">getColor</span>()) {
            symbolNode.style.color = options.getColor();
        }
    }

    return symbolNode;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.katex.Options.prototype.reset" id="apidoc.element.katex.Options.prototype.reset">
        function <span class="apidocSignatureSpan">katex.Options.prototype.</span>reset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reset = function () {
    return this.extend({});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
       baseElem.type === &#x22;close&#x22; ||
       baseElem.type === &#x22;punct&#x22;;
};

var makeNullDelimiter = function(options, classes) {
   return makeSpan(classes.concat([
       &#x22;sizing&#x22;, &#x22;reset-&#x22; + options.size, &#x22;size5&#x22;,
       options.style.<span class="apidocCodeKeywordSpan">reset</span>(), Style.TEXT.cls(),
       &#x22;nulldelimiter&#x22;]));
};

/**
* This is a map of group types to the function used to handle that type.
* Simpler types come at the beginning, while complicated types come afterwards.
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.katex.Options.prototype.withColor" id="apidoc.element.katex.Options.prototype.withColor">
        function <span class="apidocSignatureSpan">katex.Options.prototype.</span>withColor
        <span class="apidocSignatureSpan">(color)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withColor = function (color) {
    return this.extend({
        color: color
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
return makeSpan([&#x22;mord&#x22;, &#x22;text&#x22;, newOptions.style.cls()],
    inner, newOptions);
};

groupTypes.color = function(group, options) {
var elements = buildExpression(
    group.value.value,
    options.<span class="apidocCodeKeywordSpan">withColor</span>(group.value.color),
    false
);

// \color isn&#x27;t supposed to affect the type of the elements it contains.
// To accomplish this, we wrap the results in a fragment, so the inner
// elements will be able to directly interact with their neighbors. For
// example, `\color{red}{2 +} 3` has the same spacing as `2 + 3`
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.katex.Options.prototype.withFont" id="apidoc.element.katex.Options.prototype.withFont">
        function <span class="apidocSignatureSpan">katex.Options.prototype.</span>withFont
        <span class="apidocSignatureSpan">(font)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withFont = function (font) {
    return this.extend({
        font: font || this.font
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    [&#x22;mord&#x22;, options.style.cls()],
    buildExpression(group.value, options.reset(), true),
    options
);
};

groupTypes.text = function(group, options) {
var newOptions = options.<span class="apidocCodeKeywordSpan">withFont</span>(group.value.style);
var inner = buildExpression(group.value.body, newOptions, true);
for (var i = 0; i &#x3c; inner.length - 1; i++) {
    if (inner[i].tryCombine(inner[i + 1])) {
        inner.splice(i + 1, 1);
        i--;
    }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.katex.Options.prototype.withPhantom" id="apidoc.element.katex.Options.prototype.withPhantom">
        function <span class="apidocSignatureSpan">katex.Options.prototype.</span>withPhantom
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withPhantom = function () {
    return this.extend({
        phantom: true
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        return accentWrap;
    }
};

groupTypes.phantom = function(group, options) {
    var elements = buildExpression(
        group.value.value,
        options.<span class="apidocCodeKeywordSpan">withPhantom</span>(),
        false
    );

    // \phantom isn&#x27;t supposed to affect the elements it contains.
    // See &#x22;color&#x22; for more details.
    return new buildCommon.makeFragment(elements);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.katex.Options.prototype.withSize" id="apidoc.element.katex.Options.prototype.withSize">
        function <span class="apidocSignatureSpan">katex.Options.prototype.</span>withSize
        <span class="apidocSignatureSpan">(size)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withSize = function (size) {
    return this.extend({
        size: size
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

groupTypes.sizing = function(group, options) {
// Handle sizing operators like \Huge. Real TeX doesn&#x27;t actually allow
// these functions inside of math expressions, so we do some special
// handling.
var inner = buildExpression(group.value.value,
        options.<span class="apidocCodeKeywordSpan">withSize</span>(group.value.size), false);

// Compute the correct maxFontSize.
var style = options.style;
var fontSize = buildCommon.sizingMultiplier[group.value.size];
fontSize = fontSize * style.sizeMultiplier;

// Add size-resetting classes to the inner list and set maxFontSize
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.katex.Options.prototype.withStyle" id="apidoc.element.katex.Options.prototype.withStyle">
        function <span class="apidocSignatureSpan">katex.Options.prototype.</span>withStyle
        <span class="apidocSignatureSpan">(style)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withStyle = function (style) {
    return this.extend({
        style: style
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var sup;
var sub;

var style = options.style;
var newOptions;

if (group.value.sup) {
    newOptions = options.<span class="apidocCodeKeywordSpan">withStyle</span>(style.sup());
    sup = buildGroup(group.value.sup, newOptions);
    supmid = makeSpan([style.reset(), style.sup().cls()],
        [sup], newOptions);
}

if (group.value.sub) {
    newOptions = options.withStyle(style.sub());
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.katex.Parser" id="apidoc.module.katex.Parser">module katex.Parser</a></h1>


    <h2>
        <a href="#apidoc.element.katex.Parser.Parser" id="apidoc.element.katex.Parser.Parser">
        function <span class="apidocSignatureSpan">katex.</span>Parser
        <span class="apidocSignatureSpan">(input, settings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Parser(input, settings) {
    // Create a new macro expander (gullet) and (indirectly via that) also a
    // new lexer (mouth) for this parser (stomach, in the language of TeX)
    this.gullet = new MacroExpander(input, settings.macros);
    // Store the settings for use in parsing
    this.settings = settings;
    // Count leftright depth (for \middle errors)
    this.leftrightDepth = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.katex.Parser.prototype" id="apidoc.module.katex.Parser.prototype">module katex.Parser.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.katex.Parser.prototype.ParseNode" id="apidoc.element.katex.Parser.prototype.ParseNode">
        function <span class="apidocSignatureSpan">katex.Parser.prototype.</span>ParseNode
        <span class="apidocSignatureSpan">(type, value, mode, firstToken, lastToken)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ParseNode(type, value, mode, firstToken, lastToken) {
    this.type = type;
    this.value = value;
    this.mode = mode;
    if (firstToken &#x26;&#x26; (!lastToken || lastToken.lexer === firstToken.lexer)) {
        this.lexer = firstToken.lexer;
        this.start = firstToken.start;
        this.end = (lastToken || firstToken).end;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.katex.Parser.prototype.callFunction" id="apidoc.element.katex.Parser.prototype.callFunction">
        function <span class="apidocSignatureSpan">katex.Parser.prototype.</span>callFunction
        <span class="apidocSignatureSpan">(name, args, positions, token)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">callFunction = function (name, args, positions, token) {
    var context = {
        funcName: name,
        parser: this,
        positions: positions,
        token: token
    };
    return functions[name].handler(context, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

        if (denomBody.length === 1 &#x26;&#x26; denomBody[0].type === &#x22;ordgroup&#x22;) {
            denomNode = denomBody[0];
        } else {
            denomNode = new ParseNode(&#x22;ordgroup&#x22;, denomBody, this.mode);
        }

        var value = this.<span class="apidocCodeKeywordSpan">callFunction</span>(
            funcName, [numerNode, denomNode], null);
        return [new ParseNode(value.type, value, this.mode)];
    } else {
        return body;
    }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.katex.Parser.prototype.consume" id="apidoc.element.katex.Parser.prototype.consume">
        function <span class="apidocSignatureSpan">katex.Parser.prototype.</span>consume
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">consume = function () {
    this.nextToken = this.gullet.get(this.mode === &#x22;math&#x22;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   if (this.nextToken.text !== text) {
       throw new ParseError(
           &#x22;Expected &#x27;&#x22; + text + &#x22;&#x27;, got &#x27;&#x22; + this.nextToken.text + &#x22;&#x27;&#x22;,
           this.nextToken
       );
   }
   if (consume !== false) {
       this.<span class="apidocCodeKeywordSpan">consume</span>();
   }
};

/**
* Considers the current look ahead token as consumed,
* and fetches the one after that as the new look ahead.
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.katex.Parser.prototype.expect" id="apidoc.element.katex.Parser.prototype.expect">
        function <span class="apidocSignatureSpan">katex.Parser.prototype.</span>expect
        <span class="apidocSignatureSpan">(text, consume)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">expect = function (text, consume) {
    if (this.nextToken.text !== text) {
        throw new ParseError(
            &#x22;Expected &#x27;&#x22; + text + &#x22;&#x27;, got &#x27;&#x22; + this.nextToken.text + &#x22;&#x27;&#x22;,
            this.nextToken
        );
    }
    if (consume !== false) {
        this.consume();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
* Parses an entire input tree.
*/
Parser.prototype.parseInput = function() {
   // Parse an expression
   var expression = this.parseExpression(false);
   // If we succeeded, make sure there&#x27;s an EOF at the end
   this.<span class="apidocCodeKeywordSpan">expect</span>(&#x22;EOF&#x22;, false);
   return expression;
};

var endOfExpression = [&#x22;}&#x22;, &#x22;\\end&#x22;, &#x22;\\right&#x22;, &#x22;&#x26;&#x22;, &#x22;\\\\&#x22;, &#x22;\\cr&#
x22;];

/**
* Parses an &#x22;expression&#x22;, which is a list of atoms.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.katex.Parser.prototype.formLigatures" id="apidoc.element.katex.Parser.prototype.formLigatures">
        function <span class="apidocSignatureSpan">katex.Parser.prototype.</span>formLigatures
        <span class="apidocSignatureSpan">(group)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">formLigatures = function (group) {
    var i;
    var n = group.length - 1;
    for (i = 0; i &#x3c; n; ++i) {
        var a = group[i];
        var v = a.value;
        if (v === &#x22;-&#x22; &#x26;&#x26; group[i + 1].value === &#x22;-&#x22;) {
            if (i + 1 &#x3c; n &#x26;&#x26; group[i + 2].value === &#x22;-&#x22;) {
                group.splice(i, 3, new ParseNode(
                    &#x22;textord&#x22;, &#x22;---&#x22;, &#x22;text&#x22;, a, group[i + 2]));
                n -= 2;
            } else {
                group.splice(i, 2, new ParseNode(
                    &#x22;textord&#x22;, &#x22;--&#x22;, &#x22;text&#x22;, a, group[i + 1]));
                n -= 1;
            }
        }
        if ((v === &#x22;&#x27;&#x22; || v === &#x22;`&#x22;) &#x26;&#x26; group[i + 1].value === v) {
            group.splice(i, 2, new ParseNode(
                &#x22;textord&#x22;, v + v, &#x22;text&#x22;, a, group[i + 1]));
            n -= 1;
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // If we get a brace, parse an expression
    this.consume();
    var expression = this.parseExpression(false, optional ? &#x22;]&#x22; : null);
    var lastToken = this.nextToken;
    // Make sure we get a close brace
    this.expect(optional ? &#x22;]&#x22; : &#x22;}&#x22;);
    if (this.mode === &#x22;text&#x22;) {
        this.<span class="apidocCodeKeywordSpan">formLigatures</span>(expression);
    }
    return new ParseFuncOrArgument(
        new ParseNode(&#x22;ordgroup&#x22;, expression, this.mode,
                      firstToken, lastToken),
        false);
} else {
    // Otherwise, just return a nucleus, or nothing for an optional group
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.katex.Parser.prototype.handleInfixNodes" id="apidoc.element.katex.Parser.prototype.handleInfixNodes">
        function <span class="apidocSignatureSpan">katex.Parser.prototype.</span>handleInfixNodes
        <span class="apidocSignatureSpan">(body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handleInfixNodes = function (body) {
    var overIndex = -1;
    var funcName;

    for (var i = 0; i &#x3c; body.length; i++) {
        var node = body[i];
        if (node.type === &#x22;infix&#x22;) {
            if (overIndex !== -1) {
                throw new ParseError(
                    &#x22;only one infix operator per group&#x22;,
                    node.value.token);
            }
            overIndex = i;
            funcName = node.value.replaceWith;
        }
    }

    if (overIndex !== -1) {
        var numerNode;
        var denomNode;

        var numerBody = body.slice(0, overIndex);
        var denomBody = body.slice(overIndex + 1);

        if (numerBody.length === 1 &#x26;&#x26; numerBody[0].type === &#x22;ordgroup&#x22;) {
            numerNode = numerBody[0];
        } else {
            numerNode = new ParseNode(&#x22;ordgroup&#x22;, numerBody, this.mode);
        }

        if (denomBody.length === 1 &#x26;&#x26; denomBody[0].type === &#x22;ordgroup&#x22;) {
            denomNode = denomBody[0];
        } else {
            denomNode = new ParseNode(&#x22;ordgroup&#x22;, denomBody, this.mode);
        }

        var value = this.callFunction(
            funcName, [numerNode, denomNode], null);
        return [new ParseNode(value.type, value, this.mode)];
    } else {
        return body;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
               continue;
           }

           break;
       }
       body.push(atom);
   }
   return this.<span class="apidocCodeKeywordSpan">handleInfixNodes</span>(body);
};

/**
* Rewrites infix operators such as \over with corresponding commands such
* as \frac.
*
* There can only be one infix operator per group.  If there&#x27;s more than one
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.katex.Parser.prototype.handleSupSubscript" id="apidoc.element.katex.Parser.prototype.handleSupSubscript">
        function <span class="apidocSignatureSpan">katex.Parser.prototype.</span>handleSupSubscript
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handleSupSubscript = function (name) {
    var symbolToken = this.nextToken;
    var symbol = symbolToken.text;
    this.consume();
    var group = this.parseGroup();

    if (!group) {
        if (!this.settings.throwOnError &#x26;&#x26; this.nextToken.text[0] === &#x22;\\&#x22;) {
            return this.handleUnsupportedCmd();
        } else {
            throw new ParseError(
                &#x22;Expected group after &#x27;&#x22; + symbol + &#x22;&#x27;&#x22;,
                symbolToken
            );
        }
    } else if (group.isFunction) {
        // ^ and _ have a greediness, so handle interactions with functions&#x27;
        // greediness
        var funcGreediness = functions[group.result].greediness;
        if (funcGreediness &#x3e; SUPSUB_GREEDINESS) {
            return this.parseFunction(group);
        } else {
            throw new ParseError(
                &#x22;Got function &#x27;&#x22; + group.result + &#x22;&#x27; with no arguments &#x22; +
                    &#x22;as &#x22; + name, symbolToken);
        }
    } else {
        return group.result;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
    this.consume();
} else if (lex.text === &#x22;^&#x22;) {
    // We got a superscript start
    if (superscript) {
        throw new ParseError(&#x22;Double superscript&#x22;, lex);
    }
    superscript = this.<span class="apidocCodeKeywordSpan">handleSupSubscript</span>(&#x22;superscript&#x22;);
} else if (lex.text === &#x22;_&#x22;) {
    // We got a subscript start
    if (subscript) {
        throw new ParseError(&#x22;Double subscript&#x22;, lex);
    }
    subscript = this.handleSupSubscript(&#x22;subscript&#x22;);
} else if (lex.text === &#x22;&#x27;&#x22;) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.katex.Parser.prototype.handleUnsupportedCmd" id="apidoc.element.katex.Parser.prototype.handleUnsupportedCmd">
        function <span class="apidocSignatureSpan">katex.Parser.prototype.</span>handleUnsupportedCmd
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handleUnsupportedCmd = function () {
    var text = this.nextToken.text;
    var textordArray = [];

    for (var i = 0; i &#x3c; text.length; i++) {
        textordArray.push(new ParseNode(&#x22;textord&#x22;, text[i], &#x22;text&#x22;));
    }

    var textNode = new ParseNode(
        &#x22;text&#x22;,
        {
            body: textordArray,
            type: &#x22;text&#x22;
        },
        this.mode);

    var colorNode = new ParseNode(
        &#x22;color&#x22;,
        {
            color: this.settings.errorColor,
            value: [textNode],
            type: &#x22;color&#x22;
        },
        this.mode);

    this.consume();
    return colorNode;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
if (breakOnInfix &#x26;&#x26; functions[lex.text] &#x26;&#x26; functions[lex.text].infix) {
    break;
}
var atom = this.parseAtom();
if (!atom) {
    if (!this.settings.throwOnError &#x26;&#x26; lex.text[0] === &#x22;\\&#x22;) {
        var errorNode = this.<span class="apidocCodeKeywordSpan">handleUnsupportedCmd</span>();
        body.push(errorNode);
        continue;
    }

    break;
}
body.push(atom);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.katex.Parser.prototype.parse" id="apidoc.element.katex.Parser.prototype.parse">
        function <span class="apidocSignatureSpan">katex.Parser.prototype.</span>parse
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function () {
    // Try to parse the input
    this.mode = &#x22;math&#x22;;
    this.consume();
    var parse = this.parseInput();
    return parse;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * Take an entire parse tree, and build it into an appropriate set of HTML
 * nodes.
 */
var buildHTML = function(tree, options) {
// buildExpression is destructive, so we need to make a clone
// of the incoming tree so that it isn&#x27;t accidentally changed
tree = JSON.<span class="apidocCodeKeywordSpan">parse</span>(JSON.stringify(tree));

// Build the expression contained in the tree
var expression = buildExpression(tree, options, true);
var body = makeSpan([&#x22;base&#x22;, options.style.cls()], expression, options);

// Add struts, which ensure that the top of the HTML element falls at the
// height of the expression, and the bottom of the HTML element falls at the
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.katex.Parser.prototype.parseArguments" id="apidoc.element.katex.Parser.prototype.parseArguments">
        function <span class="apidocSignatureSpan">katex.Parser.prototype.</span>parseArguments
        <span class="apidocSignatureSpan">(func, funcData)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseArguments = function (func, funcData) {
    var totalArgs = funcData.numArgs + funcData.numOptionalArgs;
    if (totalArgs === 0) {
        return [[this.pos]];
    }

    var baseGreediness = funcData.greediness;
    var positions = [this.pos];
    var args = [];

    for (var i = 0; i &#x3c; totalArgs; i++) {
        var nextToken = this.nextToken;
        var argType = funcData.argTypes &#x26;&#x26; funcData.argTypes[i];
        var arg;
        if (i &#x3c; funcData.numOptionalArgs) {
            if (argType) {
                arg = this.parseGroupOfType(argType, true);
            } else {
                arg = this.parseGroup(true);
            }
            if (!arg) {
                args.push(null);
                positions.push(this.pos);
                continue;
            }
        } else {
            if (argType) {
                arg = this.parseGroupOfType(argType);
            } else {
                arg = this.parseGroup();
            }
            if (!arg) {
                if (!this.settings.throwOnError &#x26;&#x26;
                    this.nextToken.text[0] === &#x22;\\&#x22;) {
                    arg = new ParseFuncOrArgument(
                        this.handleUnsupportedCmd(this.nextToken.text),
                        false);
                } else {
                    throw new ParseError(
                        &#x22;Expected group after &#x27;&#x22; + func + &#x22;&#x27;&#x22;, nextToken);
                }
            }
        }
        var argNode;
        if (arg.isFunction) {
            var argGreediness =
                functions[arg.result].greediness;
            if (argGreediness &#x3e; baseGreediness) {
                argNode = this.parseFunction(arg);
            } else {
                throw new ParseError(
                    &#x22;Got function &#x27;&#x22; + arg.result + &#x22;&#x27; as &#x22; +
                    &#x22;argument to &#x27;&#x22; + func + &#x22;&#x27;&#x22;, nextToken);
            }
        } else {
            argNode = arg.result;
        }
        args.push(argNode);
        positions.push(this.pos);
    }

    args.push(positions);

    return args;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (!environments.hasOwnProperty(envName)) {
    throw new ParseError(
        &#x22;No such environment: &#x22; + envName, begin.value.nameGroup);
}
// Build the environment object. Arguments and other information will
// be made available to the begin and end methods using properties.
var env = environments[envName];
var args = this.<span class="apidocCodeKeywordSpan">parseArguments</span>(&#x22;\\begin{&#x22; + envName + &#x22;}&#x22;, env);
var context = {
    mode: this.mode,
    envName: envName,
    parser: this,
    positions: args.pop()
};
var result = env.handler(context, args);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.katex.Parser.prototype.parseAtom" id="apidoc.element.katex.Parser.prototype.parseAtom">
        function <span class="apidocSignatureSpan">katex.Parser.prototype.</span>parseAtom
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseAtom = function () {
    // The body of an atom is an implicit group, so that things like
    // \left(x\right)^2 work correctly.
    var base = this.parseImplicitGroup();

    // In text mode, we don&#x27;t have superscripts or subscripts
    if (this.mode === &#x22;text&#x22;) {
        return base;
    }

    // Note that base may be empty (i.e. null) at this point.

    var superscript;
    var subscript;
    while (true) {
        // Lex the first token
        var lex = this.nextToken;

        if (lex.text === &#x22;\\limits&#x22; || lex.text === &#x22;\\nolimits&#x22;) {
            // We got a limit control
            if (!base || base.type !== &#x22;op&#x22;) {
                throw new ParseError(
                    &#x22;Limit controls must follow a math operator&#x22;,
                    lex);
            } else {
                var limits = lex.text === &#x22;\\limits&#x22;;
                base.value.limits = limits;
                base.value.alwaysHandleSupSub = true;
            }
            this.consume();
        } else if (lex.text === &#x22;^&#x22;) {
            // We got a superscript start
            if (superscript) {
                throw new ParseError(&#x22;Double superscript&#x22;, lex);
            }
            superscript = this.handleSupSubscript(&#x22;superscript&#x22;);
        } else if (lex.text === &#x22;_&#x22;) {
            // We got a subscript start
            if (subscript) {
                throw new ParseError(&#x22;Double subscript&#x22;, lex);
            }
            subscript = this.handleSupSubscript(&#x22;subscript&#x22;);
        } else if (lex.text === &#x22;&#x27;&#x22;) {
            // We got a prime
            var prime = new ParseNode(&#x22;textord&#x22;, &#x22;\\prime&#x22;, this.mode);

            // Many primes can be grouped together, so we handle this here
            var primes = [prime];
            this.consume();
            // Keep lexing tokens until we get something that&#x27;s not a prime
            while (this.nextToken.text === &#x22;&#x27;&#x22;) {
                // For each one, add another prime to the list
                primes.push(prime);
                this.consume();
            }
            // Put them into an ordgroup as the superscript
            superscript = new ParseNode(&#x22;ordgroup&#x22;, primes, this.mode);
        } else {
            // If it wasn&#x27;t ^, _, or &#x27;, stop parsing super/subscripts
            break;
        }
    }

    if (superscript || subscript) {
        // If we got either a superscript or subscript, create a supsub
        return new ParseNode(&#x22;supsub&#x22;, {
            base: base,
            sup: superscript,
            sub: subscript
        }, this.mode);
    } else {
        // Otherwise return the original body
        return base;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
if (breakOnTokenText &#x26;&#x26; lex.text === breakOnTokenText) {
    break;
}
if (breakOnInfix &#x26;&#x26; functions[lex.text] &#x26;&#x26; functions[lex.text].infix) {
    break;
}
var atom = this.<span class="apidocCodeKeywordSpan">parseAtom</span>();
if (!atom) {
    if (!this.settings.throwOnError &#x26;&#x26; lex.text[0] === &#x22;\\&#x22;) {
        var errorNode = this.handleUnsupportedCmd();
        body.push(errorNode);
        continue;
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.katex.Parser.prototype.parseColorGroup" id="apidoc.element.katex.Parser.prototype.parseColorGroup">
        function <span class="apidocSignatureSpan">katex.Parser.prototype.</span>parseColorGroup
        <span class="apidocSignatureSpan">(optional)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseColorGroup = function (optional) {
    var res = this.parseStringGroup(&#x22;color&#x22;, optional);
    if (!res) {
        return null;
    }
    var match = (/^(#[a-z0-9]+|[a-z]+)$/i).exec(res.text);
    if (!match) {
        throw new ParseError(&#x22;Invalid color: &#x27;&#x22; + res.text + &#x22;&#x27;&#x22;, res);
    }
    return new ParseFuncOrArgument(
        new ParseNode(&#x22;color&#x22;, match[0], this.mode),
        false);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var outerMode = this.mode;
// Handle `original` argTypes
if (innerMode === &#x22;original&#x22;) {
    innerMode = outerMode;
}

if (innerMode === &#x22;color&#x22;) {
    return this.<span class="apidocCodeKeywordSpan">parseColorGroup</span>(optional);
}
if (innerMode === &#x22;size&#x22;) {
    return this.parseSizeGroup(optional);
}

this.switchMode(innerMode);
if (innerMode === &#x22;text&#x22;) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.katex.Parser.prototype.parseExpression" id="apidoc.element.katex.Parser.prototype.parseExpression">
        function <span class="apidocSignatureSpan">katex.Parser.prototype.</span>parseExpression
        <span class="apidocSignatureSpan">(breakOnInfix, breakOnTokenText)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseExpression = function (breakOnInfix, breakOnTokenText) {
    var body = [];
    // Keep adding atoms to the body until we can&#x27;t parse any more atoms (either
    // we reached the end, a }, or a \right)
    while (true) {
        var lex = this.nextToken;
        if (endOfExpression.indexOf(lex.text) !== -1) {
            break;
        }
        if (breakOnTokenText &#x26;&#x26; lex.text === breakOnTokenText) {
            break;
        }
        if (breakOnInfix &#x26;&#x26; functions[lex.text] &#x26;&#x26; functions[lex.text].infix) {
            break;
        }
        var atom = this.parseAtom();
        if (!atom) {
            if (!this.settings.throwOnError &#x26;&#x26; lex.text[0] === &#x22;\\&#x22;) {
                var errorNode = this.handleUnsupportedCmd();
                body.push(errorNode);
                continue;
            }

            break;
        }
        body.push(atom);
    }
    return this.handleInfixNodes(body);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

/**
 * Parses an entire input tree.
 */
Parser.prototype.parseInput = function() {
    // Parse an expression
    var expression = this.<span class="apidocCodeKeywordSpan">parseExpression</span>(false);
    // If we succeeded, make sure there&#x27;s an EOF at the end
    this.expect(&#x22;EOF&#x22;, false);
    return expression;
};

var endOfExpression = [&#x22;}&#x22;, &#x22;\\end&#x22;, &#x22;\\right&#x22;, &#x22;&#x26;&#x22;, &#x22;\\\\&#x22;, &#x22;\\cr&#
x22;];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.katex.Parser.prototype.parseFunction" id="apidoc.element.katex.Parser.prototype.parseFunction">
        function <span class="apidocSignatureSpan">katex.Parser.prototype.</span>parseFunction
        <span class="apidocSignatureSpan">(baseGroup)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseFunction = function (baseGroup) {
    if (!baseGroup) {
        baseGroup = this.parseGroup();
    }

    if (baseGroup) {
        if (baseGroup.isFunction) {
            var func = baseGroup.result;
            var funcData = functions[func];
            if (this.mode === &#x22;text&#x22; &#x26;&#x26; !funcData.allowedInText) {
                throw new ParseError(
                    &#x22;Can&#x27;t use function &#x27;&#x22; + func + &#x22;&#x27; in text mode&#x22;,
                    baseGroup.token);
            }

            var args = this.parseArguments(func, funcData);
            var token = baseGroup.token;
            var result = this.callFunction(func, args, args.pop(), token);
            return new ParseNode(result.type, result, this.mode);
        } else {
            return baseGroup.result;
        }
    } else {
        return null;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        );
    }
} else if (group.isFunction) {
    // ^ and _ have a greediness, so handle interactions with functions&#x27;
    // greediness
    var funcGreediness = functions[group.result].greediness;
    if (funcGreediness &#x3e; SUPSUB_GREEDINESS) {
        return this.<span class="apidocCodeKeywordSpan">parseFunction</span>(group);
    } else {
        throw new ParseError(
            &#x22;Got function &#x27;&#x22; + group.result + &#x22;&#x27; with no arguments &#x22; +
                &#x22;as &#x22; + name, symbolToken);
    }
} else {
    return group.result;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.katex.Parser.prototype.parseGroup" id="apidoc.element.katex.Parser.prototype.parseGroup">
        function <span class="apidocSignatureSpan">katex.Parser.prototype.</span>parseGroup
        <span class="apidocSignatureSpan">(optional)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseGroup = function (optional) {
    var firstToken = this.nextToken;
    // Try to parse an open brace
    if (this.nextToken.text === (optional ? &#x22;[&#x22; : &#x22;{&#x22;)) {
        // If we get a brace, parse an expression
        this.consume();
        var expression = this.parseExpression(false, optional ? &#x22;]&#x22; : null);
        var lastToken = this.nextToken;
        // Make sure we get a close brace
        this.expect(optional ? &#x22;]&#x22; : &#x22;}&#x22;);
        if (this.mode === &#x22;text&#x22;) {
            this.formLigatures(expression);
        }
        return new ParseFuncOrArgument(
            new ParseNode(&#x22;ordgroup&#x22;, expression, this.mode,
                          firstToken, lastToken),
            false);
    } else {
        // Otherwise, just return a nucleus, or nothing for an optional group
        return optional ? null : this.parseSymbol();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * Handle a subscript or superscript with nice errors.
 */
Parser.prototype.handleSupSubscript = function(name) {
var symbolToken = this.nextToken;
var symbol = symbolToken.text;
this.consume();
var group = this.<span class="apidocCodeKeywordSpan">parseGroup</span>();

if (!group) {
    if (!this.settings.throwOnError &#x26;&#x26; this.nextToken.text[0] === &#x22;\\&#x22;) {
        return this.handleUnsupportedCmd();
    } else {
        throw new ParseError(
            &#x22;Expected group after &#x27;&#x22; + symbol + &#x22;&#x27;&#x22;,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.katex.Parser.prototype.parseGroupOfType" id="apidoc.element.katex.Parser.prototype.parseGroupOfType">
        function <span class="apidocSignatureSpan">katex.Parser.prototype.</span>parseGroupOfType
        <span class="apidocSignatureSpan">(innerMode, optional)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseGroupOfType = function (innerMode, optional) {
    var outerMode = this.mode;
    // Handle `original` argTypes
    if (innerMode === &#x22;original&#x22;) {
        innerMode = outerMode;
    }

    if (innerMode === &#x22;color&#x22;) {
        return this.parseColorGroup(optional);
    }
    if (innerMode === &#x22;size&#x22;) {
        return this.parseSizeGroup(optional);
    }

    this.switchMode(innerMode);
    if (innerMode === &#x22;text&#x22;) {
        // text mode is special because it should ignore the whitespace before
        // it
        while (this.nextToken.text === &#x22; &#x22;) {
            this.consume();
        }
    }
    // By the time we get here, innerMode is one of &#x22;text&#x22; or &#x22;math&#x22;.
    // We switch the mode of the parser, recurse, then restore the old mode.
    var res = this.parseGroup(optional);
    this.switchMode(outerMode);
    return res;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    for (var i = 0; i &#x3c; totalArgs; i++) {
var nextToken = this.nextToken;
var argType = funcData.argTypes &#x26;&#x26; funcData.argTypes[i];
var arg;
if (i &#x3c; funcData.numOptionalArgs) {
    if (argType) {
        arg = this.<span class="apidocCodeKeywordSpan">parseGroupOfType</span>(argType, true);
    } else {
        arg = this.parseGroup(true);
    }
    if (!arg) {
        args.push(null);
        positions.push(this.pos);
        continue;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.katex.Parser.prototype.parseImplicitGroup" id="apidoc.element.katex.Parser.prototype.parseImplicitGroup">
        function <span class="apidocSignatureSpan">katex.Parser.prototype.</span>parseImplicitGroup
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseImplicitGroup = function () {
    var start = this.parseSymbol();

    if (start == null) {
        // If we didn&#x27;t get anything we handle, fall back to parseFunction
        return this.parseFunction();
    }

    var func = start.result;
    var body;

    if (func === &#x22;\\left&#x22;) {
        // If we see a left:
        // Parse the entire left function (including the delimiter)
        var left = this.parseFunction(start);
        // Parse out the implicit body
        ++this.leftrightDepth;
        body = this.parseExpression(false);
        --this.leftrightDepth;
        // Check the next token
        this.expect(&#x22;\\right&#x22;, false);
        var right = this.parseFunction();
        return new ParseNode(&#x22;leftright&#x22;, {
            body: body,
            left: left.value.value,
            right: right.value.value
        }, this.mode);
    } else if (func === &#x22;\\begin&#x22;) {
        // begin...end is similar to left...right
        var begin = this.parseFunction(start);
        var envName = begin.value.name;
        if (!environments.hasOwnProperty(envName)) {
            throw new ParseError(
                &#x22;No such environment: &#x22; + envName, begin.value.nameGroup);
        }
        // Build the environment object. Arguments and other information will
        // be made available to the begin and end methods using properties.
        var env = environments[envName];
        var args = this.parseArguments(&#x22;\\begin{&#x22; + envName + &#x22;}&#x22;, env);
        var context = {
            mode: this.mode,
            envName: envName,
            parser: this,
            positions: args.pop()
        };
        var result = env.handler(context, args);
        this.expect(&#x22;\\end&#x22;, false);
        var endNameToken = this.nextToken;
        var end = this.parseFunction();
        if (end.value.name !== envName) {
            throw new ParseError(
                &#x22;Mismatch: \\begin{&#x22; + envName + &#x22;} matched &#x22; +
                &#x22;by \\end{&#x22; + end.value.name + &#x22;}&#x22;,
                endNameToken);
        }
        result.position = end.position;
        return result;
    } else if (utils.contains(sizeFuncs, func)) {
        // If we see a sizing function, parse out the implict body
        body = this.parseExpression(false);
        return new ParseNode(&#x22;sizing&#x22;, {
            // Figure out what size to use based on the list of functions above
            size: &#x22;size&#x22; + (utils.indexOf(sizeFuncs, func) + 1),
            value: body
        }, this.mode);
    } else if (utils.contains(styleFuncs, func)) {
        // If we see a styling function, parse out the implict body
        body = this.parseExpression(true);
        return new ParseNode(&#x22;styling&#x22;, {
            // Figure out what style to use by pulling out the style from
            // the function name
            style: func.slice(1, func.length - 5),
            value: body
        }, this.mode);
    } else {
        // Defer to parseFunction if it&#x27;s not a function we handle
        return this.parseFunction(start);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Parses a group with optional super/subscripts.
 *
 * @return {?ParseNode}
 */
Parser.prototype.parseAtom = function() {
// The body of an atom is an implicit group, so that things like
// \left(x\right)^2 work correctly.
var base = this.<span class="apidocCodeKeywordSpan">parseImplicitGroup</span>();

// In text mode, we don&#x27;t have superscripts or subscripts
if (this.mode === &#x22;text&#x22;) {
    return base;
}

// Note that base may be empty (i.e. null) at this point.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.katex.Parser.prototype.parseInput" id="apidoc.element.katex.Parser.prototype.parseInput">
        function <span class="apidocSignatureSpan">katex.Parser.prototype.</span>parseInput
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseInput = function () {
    // Parse an expression
    var expression = this.parseExpression(false);
    // If we succeeded, make sure there&#x27;s an EOF at the end
    this.expect(&#x22;EOF&#x22;, false);
    return expression;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @return {?Array.&#x3c;ParseNode&#x3e;}
 */
Parser.prototype.parse = function() {
    // Try to parse the input
    this.mode = &#x22;math&#x22;;
    this.consume();
    var parse = this.<span class="apidocCodeKeywordSpan">parseInput</span>();
    return parse;
};

/**
 * Parses an entire input tree.
 */
Parser.prototype.parseInput = function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.katex.Parser.prototype.parseRegexGroup" id="apidoc.element.katex.Parser.prototype.parseRegexGroup">
        function <span class="apidocSignatureSpan">katex.Parser.prototype.</span>parseRegexGroup
        <span class="apidocSignatureSpan">(regex, modeName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseRegexGroup = function (regex, modeName) {
    var outerMode = this.mode;
    this.mode = &#x22;text&#x22;;
    var firstToken = this.nextToken;
    var lastToken = firstToken;
    var str = &#x22;&#x22;;
    while (this.nextToken.text !== &#x22;EOF&#x22;
           &#x26;&#x26; regex.test(str + this.nextToken.text)) {
        lastToken = this.nextToken;
        str += lastToken.text;
        this.consume();
    }
    if (str === &#x22;&#x22;) {
        throw new ParseError(
            &#x22;Invalid &#x22; + modeName + &#x22;: &#x27;&#x22; + firstToken.text + &#x22;&#x27;&#x22;,
            firstToken);
    }
    this.mode = outerMode;
    return firstToken.range(lastToken, str);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Parses a size specification, consisting of magnitude and unit.
 */
Parser.prototype.parseSizeGroup = function(optional) {
var res;
if (!optional &#x26;&#x26; this.nextToken.text !== &#x22;{&#x22;) {
    res = this.<span class="apidocCodeKeywordSpan">parseRegexGroup</span>(
        /^[-+]? *(?:$|\d+|\d+\.\d*|\.\d*) *[a-z]{0,2}$/, &#x22;size&#x22;);
} else {
    res = this.parseStringGroup(&#x22;size&#x22;, optional);
}
if (!res) {
    return null;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.katex.Parser.prototype.parseSizeGroup" id="apidoc.element.katex.Parser.prototype.parseSizeGroup">
        function <span class="apidocSignatureSpan">katex.Parser.prototype.</span>parseSizeGroup
        <span class="apidocSignatureSpan">(optional)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseSizeGroup = function (optional) {
    var res;
    if (!optional &#x26;&#x26; this.nextToken.text !== &#x22;{&#x22;) {
        res = this.parseRegexGroup(
            /^[-+]? *(?:$|\d+|\d+\.\d*|\.\d*) *[a-z]{0,2}$/, &#x22;size&#x22;);
    } else {
        res = this.parseStringGroup(&#x22;size&#x22;, optional);
    }
    if (!res) {
        return null;
    }
    var match = (/([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/).exec(res.text);
    if (!match) {
        throw new ParseError(&#x22;Invalid size: &#x27;&#x22; + res.text + &#x22;&#x27;&#x22;, res);
    }
    var data = {
        number: +(match[1] + match[2]), // sign + magnitude, cast to number
        unit: match[3]
    };
    if (data.unit !== &#x22;em&#x22; &#x26;&#x26; data.unit !== &#x22;ex&#x22; &#x26;&#x26; data.unit !== &#x22;mu&#x22;) {
        throw new ParseError(&#x22;Invalid unit: &#x27;&#x22; + data.unit + &#x22;&#x27;&#x22;, res);
    }
    return new ParseFuncOrArgument(
        new ParseNode(&#x22;color&#x22;, data, this.mode),
        false);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    innerMode = outerMode;
}

if (innerMode === &#x22;color&#x22;) {
    return this.parseColorGroup(optional);
}
if (innerMode === &#x22;size&#x22;) {
    return this.<span class="apidocCodeKeywordSpan">parseSizeGroup</span>(optional);
}

this.switchMode(innerMode);
if (innerMode === &#x22;text&#x22;) {
    // text mode is special because it should ignore the whitespace before
    // it
    while (this.nextToken.text === &#x22; &#x22;) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.katex.Parser.prototype.parseStringGroup" id="apidoc.element.katex.Parser.prototype.parseStringGroup">
        function <span class="apidocSignatureSpan">katex.Parser.prototype.</span>parseStringGroup
        <span class="apidocSignatureSpan">(modeName, optional)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseStringGroup = function (modeName, optional) {
    if (optional &#x26;&#x26; this.nextToken.text !== &#x22;[&#x22;) {
        return null;
    }
    var outerMode = this.mode;
    this.mode = &#x22;text&#x22;;
    this.expect(optional ? &#x22;[&#x22; : &#x22;{&#x22;);
    var str = &#x22;&#x22;;
    var firstToken = this.nextToken;
    var lastToken = firstToken;
    while (this.nextToken.text !== (optional ? &#x22;]&#x22; : &#x22;}&#x22;)) {
        if (this.nextToken.text === &#x22;EOF&#x22;) {
            throw new ParseError(
                &#x22;Unexpected end of input in &#x22; + modeName,
                firstToken.range(this.nextToken, str));
        }
        lastToken = this.nextToken;
        str += lastToken.text;
        this.consume();
    }
    this.mode = outerMode;
    this.expect(optional ? &#x22;]&#x22; : &#x22;}&#x22;);
    return firstToken.range(lastToken, str);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
return firstToken.range(lastToken, str);
};

/**
 * Parses a color description.
 */
Parser.prototype.parseColorGroup = function(optional) {
var res = this.<span class="apidocCodeKeywordSpan">parseStringGroup</span>(&#x22;color&#x22;, optional);
if (!res) {
    return null;
}
var match = (/^(#[a-z0-9]+|[a-z]+)$/i).exec(res.text);
if (!match) {
    throw new ParseError(&#x22;Invalid color: &#x27;&#x22; + res.text + &#x22;&#x27;&#x22;, res);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.katex.Parser.prototype.parseSymbol" id="apidoc.element.katex.Parser.prototype.parseSymbol">
        function <span class="apidocSignatureSpan">katex.Parser.prototype.</span>parseSymbol
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseSymbol = function () {
    var nucleus = this.nextToken;

    if (functions[nucleus.text]) {
        this.consume();
        // If there exists a function with this name, we return the function and
        // say that it is a function.
        return new ParseFuncOrArgument(
            nucleus.text,
            true, nucleus);
    } else if (symbols[this.mode][nucleus.text]) {
        this.consume();
        // Otherwise if this is a no-argument function, find the type it
        // corresponds to in the symbols map
        return new ParseFuncOrArgument(
            new ParseNode(symbols[this.mode][nucleus.text].group,
                          nucleus.text, this.mode, nucleus),
            false, nucleus);
    } else if (this.mode === &#x22;text&#x22; &#x26;&#x26; cjkRegex.test(nucleus.text)) {
        this.consume();
        return new ParseFuncOrArgument(
            new ParseNode(&#x22;textord&#x22;, nucleus.text, this.mode, nucleus),
            false, nucleus);
    } else {
        return null;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * implicit grouping after it until the end of the group. E.g.
 *   small text {\Large large text} small text again
 * It is also used for \left and \right to get the correct grouping.
 *
 * @return {?ParseNode}
 */
Parser.prototype.parseImplicitGroup = function() {
var start = this.<span class="apidocCodeKeywordSpan">parseSymbol</span>();

if (start == null) {
    // If we didn&#x27;t get anything we handle, fall back to parseFunction
    return this.parseFunction();
}

var func = start.result;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.katex.Parser.prototype.switchMode" id="apidoc.element.katex.Parser.prototype.switchMode">
        function <span class="apidocSignatureSpan">katex.Parser.prototype.</span>switchMode
        <span class="apidocSignatureSpan">(newMode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">switchMode = function (newMode) {
    this.gullet.unget(this.nextToken);
    this.mode = newMode;
    this.consume();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (innerMode === &#x22;color&#x22;) {
    return this.parseColorGroup(optional);
}
if (innerMode === &#x22;size&#x22;) {
    return this.parseSizeGroup(optional);
}

this.<span class="apidocCodeKeywordSpan">switchMode</span>(innerMode);
if (innerMode === &#x22;text&#x22;) {
    // text mode is special because it should ignore the whitespace before
    // it
    while (this.nextToken.text === &#x22; &#x22;) {
        this.consume();
    }
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.katex.buildCommon" id="apidoc.module.katex.buildCommon">module katex.buildCommon</a></h1>


    <h2>
        <a href="#apidoc.element.katex.buildCommon.makeFragment" id="apidoc.element.katex.buildCommon.makeFragment">
        function <span class="apidocSignatureSpan">katex.buildCommon.</span>makeFragment
        <span class="apidocSignatureSpan">(children)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeFragment = function (children) {
    var fragment = new domTree.documentFragment(children);

    sizeElementFromChildren(fragment);

    return fragment;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    false
);

// \color isn&#x27;t supposed to affect the type of the elements it contains.
// To accomplish this, we wrap the results in a fragment, so the inner
// elements will be able to directly interact with their neighbors. For
// example, `\color{red}{2 +} 3` has the same spacing as `2 + 3`
return new buildCommon.<span class="apidocCodeKeywordSpan">makeFragment</span>(elements);
};

groupTypes.supsub = function(group, options) {
// Superscript and subscripts are handled in the TeXbook on page
// 445-446, rules 18(a-f).

// Here is where we defer to the inner group if it should handle
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.katex.buildCommon.makeOrd" id="apidoc.element.katex.buildCommon.makeOrd">
        function <span class="apidocSignatureSpan">katex.buildCommon.</span>makeOrd
        <span class="apidocSignatureSpan">(group, options, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeOrd = function (group, options, type) {
    var mode = group.mode;
    var value = group.value;
    if (symbols[mode][value] &#x26;&#x26; symbols[mode][value].replace) {
        value = symbols[mode][value].replace;
    }

    var classes = [&#x22;mord&#x22;];

    var font = options.font;
    if (font) {
        if (font === &#x22;mathit&#x22; || utils.contains(mainitLetters, value)) {
            return mathit(value, mode, options, classes);
        } else {
            var fontName = fontMap[font].fontName;
            if (fontMetrics.getCharacterMetrics(value, fontName)) {
                return makeSymbol(
                    value, fontName, mode, options, classes.concat([font]));
            } else {
                return mathDefault(value, mode, options, classes, type);
            }
        }
    } else {
        return mathDefault(value, mode, options, classes, type);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * This is a map of group types to the function used to handle that type.
 * Simpler types come at the beginning, while complicated types come afterwards.
 */
var groupTypes = {};

groupTypes.mathord = function(group, options) {
    return buildCommon.<span class="apidocCodeKeywordSpan">makeOrd</span>(group, options, &#x22;mathord&#x22;);
};

groupTypes.textord = function(group, options) {
    return buildCommon.makeOrd(group, options, &#x22;textord&#x22;);
};

groupTypes.bin = function(group, options) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.katex.buildCommon.makeSpan" id="apidoc.element.katex.buildCommon.makeSpan">
        function <span class="apidocSignatureSpan">katex.buildCommon.</span>makeSpan
        <span class="apidocSignatureSpan">(classes, children, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeSpan = function (classes, children, options) {
    var span = new domTree.span(classes, children, options);

    sizeElementFromChildren(span);

    return span;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.katex.buildCommon.makeSymbol" id="apidoc.element.katex.buildCommon.makeSymbol">
        function <span class="apidocSignatureSpan">katex.buildCommon.</span>makeSymbol
        <span class="apidocSignatureSpan">(value, fontFamily, mode, options, classes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeSymbol = function (value, fontFamily, mode, options, classes) {
    // Replace the value with its replaced value from symbol.js
    if (symbols[mode][value] &#x26;&#x26; symbols[mode][value].replace) {
        value = symbols[mode][value].replace;
    }

    var metrics = fontMetrics.getCharacterMetrics(value, fontFamily);

    var symbolNode;
    if (metrics) {
        var italic = metrics.italic;
        if (mode === &#x22;text&#x22;) {
            italic = 0;
        }
        symbolNode = new domTree.symbolNode(
            value, metrics.height, metrics.depth, italic, metrics.skew,
            classes);
    } else {
        // TODO(emily): Figure out a good way to only print this in development
        typeof console !== &#x22;undefined&#x22; &#x26;&#x26; console.warn(
            &#x22;No character metrics for &#x27;&#x22; + value + &#x22;&#x27; in style &#x27;&#x22; +
                fontFamily + &#x22;&#x27;&#x22;);
        symbolNode = new domTree.symbolNode(value, 0, 0, 0, 0, classes);
    }

    if (options) {
        if (options.style.isTight()) {
            symbolNode.classes.push(&#x22;mtight&#x22;);
        }
        if (options.getColor()) {
            symbolNode.style.color = options.getColor();
        }
    }

    return symbolNode;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    var base;
    var baseShift = 0;
    var slant = 0;
    if (group.value.symbol) {
// If this is a symbol, create the symbol.
var fontName = large ? &#x22;Size2-Regular&#x22; : &#x22;Size1-Regular&#x22;;
base = buildCommon.<span class="apidocCodeKeywordSpan">makeSymbol</span>(
    group.value.body, fontName, &#x22;math&#x22;, options,
    [&#x22;mop&#x22;, &#x22;op-symbol&#x22;, large ? &#x22;large-op&#x22; : &#x22;small-op&#x22;]);

// Shift the symbol so its center lies on the axis (rule 13). It
// appears that our fonts have the centers of the symbols already
// almost on the axis, so these numbers are very small. Note we
// don&#x27;t actually apply this here, but instead it is used either in
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.katex.buildCommon.makeVList" id="apidoc.element.katex.buildCommon.makeVList">
        function <span class="apidocSignatureSpan">katex.buildCommon.</span>makeVList
        <span class="apidocSignatureSpan">(children, positionType, positionData, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeVList = function (children, positionType, positionData, options) {
    var depth;
    var currPos;
    var i;
    if (positionType === &#x22;individualShift&#x22;) {
        var oldChildren = children;
        children = [oldChildren[0]];

        // Add in kerns to the list of children to get each element to be
        // shifted to the correct specified shift
        depth = -oldChildren[0].shift - oldChildren[0].elem.depth;
        currPos = depth;
        for (i = 1; i &#x3c; oldChildren.length; i++) {
            var diff = -oldChildren[i].shift - currPos -
                oldChildren[i].elem.depth;
            var size = diff -
                (oldChildren[i - 1].elem.height +
                 oldChildren[i - 1].elem.depth);

            currPos = currPos + diff;

            children.push({type: &#x22;kern&#x22;, size: size});
            children.push(oldChildren[i]);
        }
    } else if (positionType === &#x22;top&#x22;) {
        // We always start at the bottom, so calculate the bottom by adding up
        // all the sizes
        var bottom = positionData;
        for (i = 0; i &#x3c; children.length; i++) {
            if (children[i].type === &#x22;kern&#x22;) {
                bottom -= children[i].size;
            } else {
                bottom -= children[i].elem.height + children[i].elem.depth;
            }
        }
        depth = bottom;
    } else if (positionType === &#x22;bottom&#x22;) {
        depth = -positionData;
    } else if (positionType === &#x22;shift&#x22;) {
        depth = -children[0].elem.depth - positionData;
    } else if (positionType === &#x22;firstBaseline&#x22;) {
        depth = -children[0].elem.depth;
    } else {
        depth = 0;
    }

    // Make the fontSizer
    var maxFontSize = 0;
    for (i = 0; i &#x3c; children.length; i++) {
        if (children[i].type === &#x22;elem&#x22;) {
            maxFontSize = Math.max(maxFontSize, children[i].elem.maxFontSize);
        }
    }
    var fontSizer = makeFontSizer(options, maxFontSize);

    // Create a new list of actual children at the correct offsets
    var realChildren = [];
    currPos = depth;
    for (i = 0; i &#x3c; children.length; i++) {
        if (children[i].type === &#x22;kern&#x22;) {
            currPos += children[i].size;
        } else {
            var child = children[i].elem;

            var shift = -child.depth - currPos;
            currPos += child.height + child.depth;

            var childWrap = makeSpan([], [fontSizer, child]);
            childWrap.height -= shift;
            childWrap.depth += shift;
            childWrap.style.top = shift + &#x22;em&#x22;;

            realChildren.push(childWrap);
        }
    }

    // Add in an element at the end with no offset to fix the calculation of
    // baselines in some browsers (namely IE, sometimes safari)
    var baselineFix = makeSpan(
        [&#x22;baseline-fix&#x22;], [fontSizer, new domTree.symbolNode(&#x22;\u200b&#x22;)]);
    realChildren.push(baselineFix);

    var vlist = makeSpan([&#x22;vlist&#x22;], realChildren);
    // Fix the final height and depth, in case there were kerns at the ends
    // since the makeSpan calculation won&#x27;t take that in to account.
    vlist.height = Math.max(currPos, vlist.height);
    vlist.depth = Math.max(-depth, vlist.depth);
    return vlist;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var supsub;
    if (!group.value.sup) {
// Rule 18b
subShift = Math.max(
    subShift, style.metrics.sub1,
    sub.height - 0.8 * style.metrics.xHeight);

supsub = buildCommon.<span class="apidocCodeKeywordSpan">makeVList</span>([
    {type: &#x22;elem&#x22;, elem: submid}
], &#x22;shift&#x22;, subShift, options);

supsub.children[0].style.marginRight = scriptspace;

// Subscripts shouldn&#x27;t be shifted by the base&#x27;s italic correction.
// Account for that by shifting the subscript back the appropriate
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.katex.buildCommon.mathsym" id="apidoc.element.katex.buildCommon.mathsym">
        function <span class="apidocSignatureSpan">katex.buildCommon.</span>mathsym
        <span class="apidocSignatureSpan">(value, mode, options, classes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mathsym = function (value, mode, options, classes) {
    // Decide what font to render the symbol in by its entry in the symbols
    // table.
    // Have a special case for when the value = \ because the \ is used as a
    // textord in unsupported command errors but cannot be parsed as a regular
    // text ordinal and is therefore not present as a symbol in the symbols
    // table for text
    if (value === &#x22;\\&#x22; || symbols[mode][value].font === &#x22;main&#x22;) {
        return makeSymbol(value, &#x22;Main-Regular&#x22;, mode, options, classes);
    } else {
        return makeSymbol(
            value, &#x22;AMS-Regular&#x22;, mode, options, classes.concat([&#x22;amsrm&#x22;]));
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

groupTypes.textord = function(group, options) {
    return buildCommon.makeOrd(group, options, &#x22;textord&#x22;);
};

groupTypes.bin = function(group, options) {
    return buildCommon.<span class="apidocCodeKeywordSpan">mathsym</span>(
        group.value, group.mode, options, [&#x22;mbin&#x22;]);
};

groupTypes.rel = function(group, options) {
    return buildCommon.mathsym(
        group.value, group.mode, options, [&#x22;mrel&#x22;]);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.katex.buildCommon.prependChildren" id="apidoc.element.katex.buildCommon.prependChildren">
        function <span class="apidocSignatureSpan">katex.buildCommon.</span>prependChildren
        <span class="apidocSignatureSpan">(span, children)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prependChildren = function (span, children) {
    span.children = children.concat(span.children);

    sizeElementFromChildren(span);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        spaces.push(groups[i]);
        groups.splice(i, 1);
        i--;
    } else if (spaces) {
        if (groups[i] instanceof domTree.symbolNode) {
            groups[i] = makeSpan([].concat(groups[i].classes), [groups[i]]);
        }
        buildCommon.<span class="apidocCodeKeywordSpan">prependChildren</span>(groups[i], spaces);
        spaces = null;
    }
}
if (spaces) {
    Array.prototype.push.apply(groups, spaces);
}
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.katex.delimiter" id="apidoc.module.katex.delimiter">module katex.delimiter</a></h1>


    <h2>
        <a href="#apidoc.element.katex.delimiter.customSizedDelim" id="apidoc.element.katex.delimiter.customSizedDelim">
        function <span class="apidocSignatureSpan">katex.delimiter.</span>customSizedDelim
        <span class="apidocSignatureSpan">(delim, height, center, options, mode, classes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">customSizedDelim = function (delim, height, center, options, mode, classes) {
    if (delim === &#x22;&#x3c;&#x22; || delim === &#x22;\\lt&#x22;) {
        delim = &#x22;\\langle&#x22;;
    } else if (delim === &#x22;&#x3e;&#x22; || delim === &#x22;\\gt&#x22;) {
        delim = &#x22;\\rangle&#x22;;
    }

    // Decide what sequence to use
    var sequence;
    if (utils.contains(stackNeverDelimiters, delim)) {
        sequence = stackNeverDelimiterSequence;
    } else if (utils.contains(stackLargeDelimiters, delim)) {
        sequence = stackLargeDelimiterSequence;
    } else {
        sequence = stackAlwaysDelimiterSequence;
    }

    // Look through the sequence
    var delimType = traverseSequence(delim, height, sequence, options);

    // Depending on the sequence element we decided on, call the appropriate
    // function.
    if (delimType.type === &#x22;small&#x22;) {
        return makeSmallDelim(delim, delimType.style, center, options, mode,
                              classes);
    } else if (delimType.type === &#x22;large&#x22;) {
        return makeLargeDelim(delim, delimType.size, center, options, mode,
                              classes);
    } else if (delimType.type === &#x22;stack&#x22;) {
        return makeStackedDelim(delim, height, center, options, mode, classes);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

var leftDelim;
var rightDelim;
if (group.value.leftDelim == null) {
    leftDelim = makeNullDelimiter(options, [&#x22;mopen&#x22;]);
} else {
    leftDelim = delimiter.<span class="apidocCodeKeywordSpan">customSizedDelim</span>(
        group.value.leftDelim, delimSize, true,
        options.withStyle(style), group.mode, [&#x22;mopen&#x22;]);
}
if (group.value.rightDelim == null) {
    rightDelim = makeNullDelimiter(options, [&#x22;mclose&#x22;]);
} else {
    rightDelim = delimiter.customSizedDelim(
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.katex.delimiter.leftRightDelim" id="apidoc.element.katex.delimiter.leftRightDelim">
        function <span class="apidocSignatureSpan">katex.delimiter.</span>leftRightDelim
        <span class="apidocSignatureSpan">(delim, height, depth, options, mode, classes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">leftRightDelim = function (delim, height, depth, options, mode, classes) {
    // We always center \left/\right delimiters, so the axis is always shifted
    var axisHeight =
        options.style.metrics.axisHeight * options.style.sizeMultiplier;

    // Taken from TeX source, tex.web, function make_left_right
    var delimiterFactor = 901;
    var delimiterExtend = 5.0 / fontMetrics.metrics.ptPerEm;

    var maxDistFromAxis = Math.max(
        height - axisHeight, depth + axisHeight);

    var totalHeight = Math.max(
        // In real TeX, calculations are done using integral values which are
        // 65536 per pt, or 655360 per em. So, the division here truncates in
        // TeX but doesn&#x27;t here, producing different results. If we wanted to
        // exactly match TeX&#x27;s calculation, we could do
        //   Math.floor(655360 * maxDistFromAxis / 500) *
        //    delimiterFactor / 655360
        // (To see the difference, compare
        //    x^{x^{\left(\rule{0.1em}{0.68em}\right)}}
        // in TeX and KaTeX)
        maxDistFromAxis / 500 * delimiterFactor,
        2 * maxDistFromAxis - delimiterExtend);

    // Finally, we defer to `makeCustomSizedDelim` with our calculated total
    // height
    return makeCustomSizedDelim(delim, totalHeight, true, options, mode,
                                classes);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var leftDelim;
if (group.value.left === &#x22;.&#x22;) {
    // Empty delimiters in \left and \right make null delimiter spaces.
    leftDelim = makeNullDelimiter(options, [&#x22;mopen&#x22;]);
} else {
    // Otherwise, use leftRightDelim to generate the correct sized
    // delimiter.
    leftDelim = delimiter.<span class="apidocCodeKeywordSpan">leftRightDelim</span>(
        group.value.left, innerHeight, innerDepth, options,
        group.mode, [&#x22;mopen&#x22;]);
}
// Add it to the beginning of the expression
inner.unshift(leftDelim);

// Handle middle delimiters
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.katex.delimiter.sizedDelim" id="apidoc.element.katex.delimiter.sizedDelim">
        function <span class="apidocSignatureSpan">katex.delimiter.</span>sizedDelim
        <span class="apidocSignatureSpan">(delim, size, options, mode, classes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sizedDelim = function (delim, size, options, mode, classes) {
    // &#x3c; and &#x3e; turn into \langle and \rangle in delimiters
    if (delim === &#x22;&#x3c;&#x22; || delim === &#x22;\\lt&#x22;) {
        delim = &#x22;\\langle&#x22;;
    } else if (delim === &#x22;&#x3e;&#x22; || delim === &#x22;\\gt&#x22;) {
        delim = &#x22;\\rangle&#x22;;
    }

    // Sized delimiters are never centered.
    if (utils.contains(stackLargeDelimiters, delim) ||
        utils.contains(stackNeverDelimiters, delim)) {
        return makeLargeDelim(delim, size, false, options, mode, classes);
    } else if (utils.contains(stackAlwaysDelimiters, delim)) {
        return makeStackedDelim(
            delim, sizeToMaxHeight[size], false, options, mode, classes);
    } else {
        throw new ParseError(&#x22;Illegal delimiter: &#x27;&#x22; + delim + &#x22;&#x27;&#x22;);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (delim === &#x22;.&#x22;) {
    // Empty delimiters still count as elements, even though they don&#x27;t
    // show anything.
    return makeSpan([group.value.mclass]);
}

// Use delimiter.sizedDelim to generate the delimiter.
return delimiter.<span class="apidocCodeKeywordSpan">sizedDelim</span>(
        delim, group.value.size, options, group.mode,
        [group.value.mclass]);
};

groupTypes.leftright = function(group, options) {
// Build the inner expression
var inner = buildExpression(group.value.body, options.reset(), true);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.katex.domTree" id="apidoc.module.katex.domTree">module katex.domTree</a></h1>


    <h2>
        <a href="#apidoc.element.katex.domTree.documentFragment" id="apidoc.element.katex.domTree.documentFragment">
        function <span class="apidocSignatureSpan">katex.domTree.</span>documentFragment
        <span class="apidocSignatureSpan">(children)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function documentFragment(children) {
    this.children = children || [];
    this.height = 0;
    this.depth = 0;
    this.maxFontSize = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    sizeElementFromChildren(span);
};

/**
 * Makes a document fragment with the given list of children.
 */
var makeFragment = function(children) {
    var fragment = new domTree.<span class="apidocCodeKeywordSpan">documentFragment</span>(children);

    sizeElementFromChildren(fragment);

    return fragment;
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.katex.domTree.span" id="apidoc.element.katex.domTree.span">
        function <span class="apidocSignatureSpan">katex.domTree.</span>span
        <span class="apidocSignatureSpan">(classes, children, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function span(classes, children, options) {
    this.classes = classes || [];
    this.children = children || [];
    this.height = 0;
    this.depth = 0;
    this.maxFontSize = 0;
    this.style = {};
    this.attributes = {};
    if (options) {
        if (options.style.isTight()) {
            this.classes.push(&#x22;mtight&#x22;);
        }
        if (options.getColor()) {
            this.style.color = options.getColor();
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * TODO: Ensure that `options` is always provided (currently some call sites
 * don&#x27;t pass it).
 * TODO: add a separate argument for math class (e.g. `mop`, `mbin`), which
 * should if present come first in `classes`.
 */
var makeSpan = function(classes, children, options) {
    var span = new domTree.<span class="apidocCodeKeywordSpan">span</span>(classes, children, options);

    sizeElementFromChildren(span);

    return span;
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.katex.domTree.symbolNode" id="apidoc.element.katex.domTree.symbolNode">
        function <span class="apidocSignatureSpan">katex.domTree.</span>symbolNode
        <span class="apidocSignatureSpan">(value, height, depth, italic, skew, classes, style)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function symbolNode(value, height, depth, italic, skew, classes, style) {
    this.value = value || &#x22;&#x22;;
    this.height = height || 0;
    this.depth = depth || 0;
    this.italic = italic || 0;
    this.skew = skew || 0;
    this.classes = classes || [];
    this.style = style || {};
    this.maxFontSize = 0;

    // Mark CJK characters with specific classes so that we can specify which
    // fonts to use.  This allows us to render these characters with a serif
    // font in situations where the browser would either default to a sans serif
    // or render a placeholder character.
    if (unicodeRegexes.cjkRegex.test(value)) {
        // I couldn&#x27;t find any fonts that contained Hangul as well as all of
        // the other characters we wanted to test there for it gets its own
        // CSS class.
        if (unicodeRegexes.hangulRegex.test(value)) {
            this.classes.push(&#x27;hangul_fallback&#x27;);
        } else {
            this.classes.push(&#x27;cjk_fallback&#x27;);
        }
    }

    if (/[îïíì]/.test(this.value)) {    // add ī when we add Extended Latin
        this.value = iCombinations[this.value];
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var symbolNode;
if (metrics) {
    var italic = metrics.italic;
    if (mode === &#x22;text&#x22;) {
        italic = 0;
    }
    symbolNode = new domTree.<span class="apidocCodeKeywordSpan">symbolNode</span>(
        value, metrics.height, metrics.depth, italic, metrics.skew,
        classes);
} else {
    // TODO(emily): Figure out a good way to only print this in development
    typeof console !== &#x22;undefined&#x22; &#x26;&#x26; console.warn(
        &#x22;No character metrics for &#x27;&#x22; + value + &#x22;&#x27; in style &#x27;&#x22; +
            fontFamily + &#x22;&#x27;&#x22;);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.katex.fontMetrics" id="apidoc.module.katex.fontMetrics">module katex.fontMetrics</a></h1>


    <h2>
        <a href="#apidoc.element.katex.fontMetrics.getCharacterMetrics" id="apidoc.element.katex.fontMetrics.getCharacterMetrics">
        function <span class="apidocSignatureSpan">katex.fontMetrics.</span>getCharacterMetrics
        <span class="apidocSignatureSpan">(character, style)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getCharacterMetrics = function (character, style) {
    var ch = character.charCodeAt(0);
    if (character[0] in extraCharacterMap) {
        ch = extraCharacterMap[character[0]].charCodeAt(0);
    } else if (cjkRegex.test(character[0])) {
        ch = &#x27;M&#x27;.charCodeAt(0);
    }
    var metrics = metricMap[style][ch];
    if (metrics) {
        return {
            depth: metrics[0],
            height: metrics[1],
            italic: metrics[2],
            skew: metrics[3],
            width: metrics[4]
        };
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
var makeSymbol = function(value, fontFamily, mode, options, classes) {
// Replace the value with its replaced value from symbol.js
if (symbols[mode][value] &#x26;&#x26; symbols[mode][value].replace) {
    value = symbols[mode][value].replace;
}

var metrics = fontMetrics.<span class="apidocCodeKeywordSpan">getCharacterMetrics</span>(value, fontFamily);

var symbolNode;
if (metrics) {
    var italic = metrics.italic;
    if (mode === &#x22;text&#x22;) {
        italic = 0;
    }
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.katex.mathMLTree" id="apidoc.module.katex.mathMLTree">module katex.mathMLTree</a></h1>


    <h2>
        <a href="#apidoc.element.katex.mathMLTree.MathNode" id="apidoc.element.katex.mathMLTree.MathNode">
        function <span class="apidocSignatureSpan">katex.mathMLTree.</span>MathNode
        <span class="apidocSignatureSpan">(type, children)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MathNode(type, children) {
    this.type = type;
    this.attributes = {};
    this.children = children || [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * Functions for handling the different types of groups found in the parse
 * tree. Each function should take a parse group and return a MathML node.
 */
var groupTypes = {};

groupTypes.mathord = function(group, options) {
var node = new mathMLTree.<span class="apidocCodeKeywordSpan">MathNode</span>(
    &#x22;mi&#x22;,
    [makeText(group.value, group.mode)]);

var variant = getVariant(group, options);
if (variant) {
    node.setAttribute(&#x22;mathvariant&#x22;, variant);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.katex.mathMLTree.TextNode" id="apidoc.element.katex.mathMLTree.TextNode">
        function <span class="apidocSignatureSpan">katex.mathMLTree.</span>TextNode
        <span class="apidocSignatureSpan">(text)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TextNode(text) {
    this.text = text;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * optional replacement from symbols.js.
 */
var makeText = function(text, mode) {
if (symbols[mode][text] &#x26;&#x26; symbols[mode][text].replace) {
    text = symbols[mode][text].replace;
}

return new mathMLTree.<span class="apidocCodeKeywordSpan">TextNode</span>(text);
};

/**
 * Returns the math variant as a string or null if none is required.
 */
var getVariant = function(group, options) {
var font = options.font;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.katex.parseData" id="apidoc.module.katex.parseData">module katex.parseData</a></h1>


    <h2>
        <a href="#apidoc.element.katex.parseData.ParseNode" id="apidoc.element.katex.parseData.ParseNode">
        function <span class="apidocSignatureSpan">katex.parseData.</span>ParseNode
        <span class="apidocSignatureSpan">(type, value, mode, firstToken, lastToken)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ParseNode(type, value, mode, firstToken, lastToken) {
    this.type = type;
    this.value = value;
    this.mode = mode;
    if (firstToken &#x26;&#x26; (!lastToken || lastToken.lexer === firstToken.lexer)) {
        this.lexer = firstToken.lexer;
        this.start = firstToken.start;
        this.end = (lastToken || firstToken).end;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.katex.utils" id="apidoc.module.katex.utils">module katex.utils</a></h1>


    <h2>
        <a href="#apidoc.element.katex.utils.clearNode" id="apidoc.element.katex.utils.clearNode">
        function <span class="apidocSignatureSpan">katex.utils.</span>clearNode
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function clearNode(node) {
    setTextContent(node, &#x22;&#x22;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var utils = require(&#x22;./src/utils&#x22;);

/**
 * Parse and build an expression, and place that expression in the DOM node
 * given.
 */
var render = function(expression, baseNode, options) {
utils.<span class="apidocCodeKeywordSpan">clearNode</span>(baseNode);

var settings = new Settings(options);

var tree = parseTree(expression, settings);
var node = buildTree(tree, expression, settings).toNode();

baseNode.appendChild(node);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.katex.utils.contains" id="apidoc.element.katex.utils.contains">
        function <span class="apidocSignatureSpan">katex.utils.</span>contains
        <span class="apidocSignatureSpan">(list, elem)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">contains = function (list, elem) {
    return indexOf(list, elem) !== -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        throw new ParseError(
            &#x22;Mismatch: \\begin{&#x22; + envName + &#x22;} matched &#x22; +
            &#x22;by \\end{&#x22; + end.value.name + &#x22;}&#x22;,
            endNameToken);
    }
    result.position = end.position;
    return result;
} else if (utils.<span class="apidocCodeKeywordSpan">contains</span>(sizeFuncs, func)) {
    // If we see a sizing function, parse out the implict body
    body = this.parseExpression(false);
    return new ParseNode(&#x22;sizing&#x22;, {
        // Figure out what size to use based on the list of functions above
        size: &#x22;size&#x22; + (utils.indexOf(sizeFuncs, func) + 1),
        value: body
    }, this.mode);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.katex.utils.deflt" id="apidoc.element.katex.utils.deflt">
        function <span class="apidocSignatureSpan">katex.utils.</span>deflt
        <span class="apidocSignatureSpan">(setting, defaultIfUndefined)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deflt = function (setting, defaultIfUndefined) {
    return setting === undefined ? defaultIfUndefined : setting;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var pt = 1 / fontMetrics.metrics.ptPerEm;
var arraycolsep = 5 * pt; // \arraycolsep in article.cls

// Vertical spacing
var baselineskip = 12 * pt; // see size10.clo
// Default \arraystretch from lttab.dtx
// TODO(gagern): may get redefined once we have user-defined macros
var arraystretch = utils.<span class="apidocCodeKeywordSpan">deflt</span>(group.value.arraystretch, 1);
var arrayskip = arraystretch * baselineskip;
var arstrutHeight = 0.7 * arrayskip; // \strutbox in ltfsstrc.dtx and
var arstrutDepth = 0.3 * arrayskip;  // \@arstrutbox in lttab.dtx

var totalHeight = 0;
for (r = 0; r &#x3c; group.value.body.length; ++r) {
    var inrow = group.value.body[r];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.katex.utils.escape" id="apidoc.element.katex.utils.escape">
        function <span class="apidocSignatureSpan">katex.utils.</span>escape
        <span class="apidocSignatureSpan">(text)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function escape(text) {
    return (&#x22;&#x22; + text).replace(ESCAPE_REGEX, escaper);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
span.prototype.toMarkup = function() {
var markup = &#x22;&#x3c;span&#x22;;

// Add the class
if (this.classes.length) {
    markup += &#x22; class=\&#x22;&#x22;;
    markup += utils.<span class="apidocCodeKeywordSpan">escape</span>(createClass(this.classes));
    markup += &#x22;\&#x22;&#x22;;
}

var styles = &#x22;&#x22;;

// Add the styles, after hyphenation
for (var style in this.style) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.katex.utils.hyphenate" id="apidoc.element.katex.utils.hyphenate">
        function <span class="apidocSignatureSpan">katex.utils.</span>hyphenate
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hyphenate = function (str) {
    return str.replace(uppercase, &#x22;-$1&#x22;).toLowerCase();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

var styles = &#x22;&#x22;;

// Add the styles, after hyphenation
for (var style in this.style) {
    if (this.style.hasOwnProperty(style)) {
        styles += utils.<span class="apidocCodeKeywordSpan">hyphenate</span>(style) + &#x22;:&#x22; + this.style[style] + &#x22;;&#
x22;;
    }
}

if (styles) {
    markup += &#x22; style=\&#x22;&#x22; + utils.escape(styles) + &#x22;\&#x22;&#x22;;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.katex.utils.indexOf" id="apidoc.element.katex.utils.indexOf">
        function <span class="apidocSignatureSpan">katex.utils.</span>indexOf
        <span class="apidocSignatureSpan">(list, elem)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">indexOf = function (list, elem) {
    if (list == null) {
        return -1;
    }
    if (nativeIndexOf &#x26;&#x26; list.indexOf === nativeIndexOf) {
        return list.indexOf(elem);
    }
    var i = 0;
    var l = list.length;
    for (; i &#x3c; l; i++) {
        if (list[i] === elem) {
            return i;
        }
    }
    return -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var katex = require(&#x22;./&#x22;);
var input = &#x22;&#x22;;

// Skip the first two args, which are just &#x22;node&#x22; and &#x22;cli.js&#x22;
var args = process.argv.slice(2);

if (args.<span class="apidocCodeKeywordSpan">indexOf</span>(&#x22;--help&#x22;) !== -1) {
console.log(process.argv[0] + &#x22; &#x22; + process.argv[1] +
            &#x22; [ --help ]&#x22; +
            &#x22; [ --display-mode ]&#x22;);

console.log(&#x22;\n&#x22; +
            &#x22;Options:&#x22;);
console.log(&#x22;  --help            Display this help message&#x22;);
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
